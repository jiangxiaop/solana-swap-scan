'use strict';

var codecsCore = require('@solana/codecs-core');
var codecsDataStructures = require('@solana/codecs-data-structures');
var codecsNumbers = require('@solana/codecs-numbers');

// src/option.ts
var some = (value) => ({ __option: "Some", value });
var none = () => ({ __option: "None" });
var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
var isSome = (option) => option.__option === "Some";
var isNone = (option) => option.__option === "None";

// src/unwrap-option.ts
function unwrapOption(option, fallback) {
  if (isSome(option))
    return option.value;
  return fallback ? fallback() : null;
}
var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();

// src/option-codec.ts
function getOptionEncoder(item, config = {}) {
  const prefix = config.prefix ?? codecsNumbers.getU8Encoder();
  const fixed = config.fixed ?? false;
  const encoder = codecsDataStructures.getUnionEncoder(
    [
      codecsCore.transformEncoder(prefix, (_value) => 0),
      codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, item]), (value) => {
        return [1, isOption(value) && isSome(value) ? value.value : value];
      })
    ],
    (variant) => {
      const option = isOption(variant) ? variant : wrapNullable(variant);
      return Number(isSome(option));
    }
  );
  if (!fixed)
    return encoder;
  codecsCore.assertIsFixedSize(item);
  codecsCore.assertIsFixedSize(prefix);
  return codecsCore.fixEncoderSize(encoder, prefix.fixedSize + item.fixedSize);
}
function getOptionDecoder(item, config = {}) {
  const prefix = config.prefix ?? codecsNumbers.getU8Decoder();
  const fixed = config.fixed ?? false;
  const decoder = codecsDataStructures.getUnionDecoder(
    [
      codecsCore.transformDecoder(prefix, (_value) => none()),
      codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, item]), ([, value]) => some(value))
    ],
    (bytes, offset) => Number(prefix.read(bytes, offset)[0] !== 0)
  );
  if (!fixed)
    return decoder;
  codecsCore.assertIsFixedSize(item);
  codecsCore.assertIsFixedSize(prefix);
  return codecsCore.fixDecoderSize(decoder, prefix.fixedSize + item.fixedSize);
}
function getOptionCodec(item, config = {}) {
  return codecsCore.combineCodec(
    getOptionEncoder(item, config),
    getOptionDecoder(item, config)
  );
}

// src/unwrap-option-recursively.ts
function unwrapOptionRecursively(input, fallback) {
  if (!input || ArrayBuffer.isView(input)) {
    return input;
  }
  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
  if (isOption(input)) {
    if (isSome(input))
      return next(input.value);
    return fallback ? fallback() : null;
  }
  if (Array.isArray(input)) {
    return input.map(next);
  }
  if (typeof input === "object") {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
  }
  return input;
}

exports.getOptionCodec = getOptionCodec;
exports.getOptionDecoder = getOptionDecoder;
exports.getOptionEncoder = getOptionEncoder;
exports.isNone = isNone;
exports.isOption = isOption;
exports.isSome = isSome;
exports.none = none;
exports.some = some;
exports.unwrapOption = unwrapOption;
exports.unwrapOptionRecursively = unwrapOptionRecursively;
exports.wrapNullable = wrapNullable;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.browser.cjs.map