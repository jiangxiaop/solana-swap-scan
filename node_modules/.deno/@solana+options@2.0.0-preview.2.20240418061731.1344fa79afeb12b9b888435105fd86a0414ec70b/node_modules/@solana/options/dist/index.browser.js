import { transformEncoder, assertIsFixedSize, fixEncoderSize, transformDecoder, fixDecoderSize, combineCodec } from '@solana/codecs-core';
import { getUnionEncoder, getTupleEncoder, getUnionDecoder, getTupleDecoder } from '@solana/codecs-data-structures';
import { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';

// src/option.ts
var some = (value) => ({ __option: "Some", value });
var none = () => ({ __option: "None" });
var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
var isSome = (option) => option.__option === "Some";
var isNone = (option) => option.__option === "None";

// src/unwrap-option.ts
function unwrapOption(option, fallback) {
  if (isSome(option))
    return option.value;
  return fallback ? fallback() : null;
}
var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();

// src/option-codec.ts
function getOptionEncoder(item, config = {}) {
  const prefix = config.prefix ?? getU8Encoder();
  const fixed = config.fixed ?? false;
  const encoder = getUnionEncoder(
    [
      transformEncoder(prefix, (_value) => 0),
      transformEncoder(getTupleEncoder([prefix, item]), (value) => {
        return [1, isOption(value) && isSome(value) ? value.value : value];
      })
    ],
    (variant) => {
      const option = isOption(variant) ? variant : wrapNullable(variant);
      return Number(isSome(option));
    }
  );
  if (!fixed)
    return encoder;
  assertIsFixedSize(item);
  assertIsFixedSize(prefix);
  return fixEncoderSize(encoder, prefix.fixedSize + item.fixedSize);
}
function getOptionDecoder(item, config = {}) {
  const prefix = config.prefix ?? getU8Decoder();
  const fixed = config.fixed ?? false;
  const decoder = getUnionDecoder(
    [
      transformDecoder(prefix, (_value) => none()),
      transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))
    ],
    (bytes, offset) => Number(prefix.read(bytes, offset)[0] !== 0)
  );
  if (!fixed)
    return decoder;
  assertIsFixedSize(item);
  assertIsFixedSize(prefix);
  return fixDecoderSize(decoder, prefix.fixedSize + item.fixedSize);
}
function getOptionCodec(item, config = {}) {
  return combineCodec(
    getOptionEncoder(item, config),
    getOptionDecoder(item, config)
  );
}

// src/unwrap-option-recursively.ts
function unwrapOptionRecursively(input, fallback) {
  if (!input || ArrayBuffer.isView(input)) {
    return input;
  }
  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
  if (isOption(input)) {
    if (isSome(input))
      return next(input.value);
    return fallback ? fallback() : null;
  }
  if (Array.isArray(input)) {
    return input.map(next);
  }
  if (typeof input === "object") {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
  }
  return input;
}

export { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.browser.js.map